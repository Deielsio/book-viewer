import React, { useState } from 'react';
import { Upload, FileText, ZoomIn, ZoomOut, AlertCircle, Save, Copy, Printer, MoreVertical, Menu, File, FolderOpen } from 'lucide-react';

const BookViewer = () => {
  const [file, setFile] = useState(null);
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(false);
  const [zoom, setZoom] = useState(100);
  const [fileType, setFileType] = useState('');
  const [error, setError] = useState('');
  const [showUpload, setShowUpload] = useState(false);
  const [scrollPosition, setScrollPosition] = useState(0);
  const [showRecap, setShowRecap] = useState(false);
  const [recap, setRecap] = useState('');
  const [loadingRecap, setLoadingRecap] = useState(false);
  const [readingProgress, setReadingProgress] = useState(0);
  const [apiKey, setApiKey] = useState('');
  const [showApiKeyPrompt, setShowApiKeyPrompt] = useState(false);
  const [showTutorial, setShowTutorial] = useState(false);
  const [recentBooks, setRecentBooks] = useState([]);
  const [showStartScreen, setShowStartScreen] = useState(true);
  const [fileInputRef] = useState(React.createRef());
  const contentRef = React.useRef(null);

  // Load recent books on mount
  React.useEffect(() => {
    loadRecentBooks();
  }, []);

  const loadRecentBooks = async () => {
    const books = [];
    const bookHistory = JSON.parse(localStorage.getItem('book_history') || '[]');
    
    for (let i = 0; i < Math.min(8, bookHistory.length); i++) {
      const bookData = bookHistory[i];
      const progress = localStorage.getItem(`progress_${bookData.filename}`) || 0;
      
      // Try to fetch metadata from Open Library
      let metadata = null;
      if (bookData.title) {
        try {
          const response = await fetch(`https://openlibrary.org/search.json?title=${encodeURIComponent(bookData.title)}&limit=1`);
          const data = await response.json();
          if (data.docs && data.docs.length > 0) {
            const book = data.docs[0];
            metadata = {
              title: book.title,
              author: book.author_name?.[0] || 'Unknown Author',
              year: book.first_publish_year || null,
              coverId: book.cover_i,
              pageCount: book.number_of_pages_median || null
            };
          }
        } catch (error) {
          console.error('Error fetching book metadata:', error);
        }
      }
      
      books.push({
        filename: bookData.filename,
        lastOpened: bookData.lastOpened,
        progress: Math.round(parseFloat(progress)),
        metadata: metadata || {
          title: bookData.title || bookData.filename,
          author: 'Unknown Author',
          year: null,
          coverId: null,
          pageCount: null
        }
      });
    }
    
    setRecentBooks(books);
  };

  const saveToHistory = (filename) => {
    // Extract potential title from filename
    const title = filename.replace(/\.(epub|pdf)$/i, '').replace(/[-_]/g, ' ');
    
    const history = JSON.parse(localStorage.getItem('book_history') || '[]');
    const existingIndex = history.findIndex(b => b.filename === filename);
    
    const bookEntry = {
      filename: filename,
      title: title,
      lastOpened: new Date().toISOString()
    };
    
    if (existingIndex >= 0) {
      history.splice(existingIndex, 1);
    }
    
    history.unshift(bookEntry);
    
    // Keep only last 8 books
    if (history.length > 8) {
      history.pop();
    }
    
    localStorage.setItem('book_history', JSON.stringify(history));
  };

  const handleBookCardClick = (bookFilename) => {
    // Show message that user needs to select the same file
    const confirmMessage = `To reopen "${bookFilename}", please select it from your files.\n\nNote: Your browser can't automatically access files for security reasons, but your bookmark and progress are saved!`;
    
    if (confirm(confirmMessage)) {
      // Trigger file input
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.epub,.pdf,application/epub+zip,application/pdf';
      input.onchange = async (e) => {
        const selectedFile = e.target.files[0];
        if (selectedFile && selectedFile.name === bookFilename) {
          await handleFileUpload({ target: { files: [selectedFile] } });
        } else if (selectedFile) {
          alert(`Please select the file "${bookFilename}" to restore your progress.`);
        }
      };
      input.click();
    }
  };

  const loadJSZip = () => {
    return new Promise((resolve, reject) => {
      if (window.JSZip) {
        resolve(window.JSZip);
        return;
      }
      
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
      script.onload = () => resolve(window.JSZip);
      script.onerror = () => reject(new Error('Failed to load JSZip library'));
      document.head.appendChild(script);
    });
  };

  // Save scroll position when user scrolls
  const handleScroll = (e) => {
    if (file) {
      const position = e.target.scrollTop;
      const scrollHeight = e.target.scrollHeight - e.target.clientHeight;
      const progress = scrollHeight > 0 ? (position / scrollHeight) * 100 : 0;
      
      setScrollPosition(position);
      setReadingProgress(Math.min(Math.round(progress), 100));
      localStorage.setItem(`bookmark_${file.name}`, position.toString());
      localStorage.setItem(`progress_${file.name}`, progress.toString());
    }
  };

  // Restore scroll position after content loads
  React.useEffect(() => {
    if (content && file && contentRef.current) {
      const savedPosition = localStorage.getItem(`bookmark_${file.name}`);
      const savedProgress = localStorage.getItem(`progress_${file.name}`);
      
      if (savedProgress) {
        setReadingProgress(Math.round(parseFloat(savedProgress)));
      }
      
      if (savedPosition && parseInt(savedPosition) > 500) {
        // Check if user has API key stored
        const storedKey = localStorage.getItem('gemini_api_key');
        if (storedKey) {
          setApiKey(storedKey);
          setShowRecap(true);
          generateRecap(savedPosition, storedKey);
        } else {
          // Show API key prompt
          setShowApiKeyPrompt(true);
        }
      } else if (savedPosition) {
        setTimeout(() => {
          contentRef.current.scrollTop = parseInt(savedPosition);
        }, 100);
      }
    }
  }, [content, file]);

  const generateRecap = async (position, key) => {
    setLoadingRecap(true);
    try {
      // Extract text content up to the bookmark position
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const fullText = tempDiv.innerText || tempDiv.textContent;
      
      // Estimate character position based on scroll
      const scrollPercentage = Math.min(parseInt(position) / 2000, 1);
      const charPosition = Math.floor(fullText.length * scrollPercentage);
      const readText = fullText.substring(Math.max(0, charPosition - 3000), charPosition);
      
      // Use Gemini API (free tier)
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${key}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: `Please provide a brief 2-3 sentence recap of what happened in this text excerpt. Focus on the key events and main points:\n\n${readText.slice(-2000)}`
            }]
          }]
        })
      });

      const data = await response.json();
      
      if (data.candidates && data.candidates[0]?.content?.parts?.[0]?.text) {
        setRecap(data.candidates[0].content.parts[0].text);
      } else {
        setRecap('Unable to generate recap. Please check your API key.');
      }
    } catch (error) {
      console.error('Error generating recap:', error);
      setRecap('Unable to generate recap. Please check your API key and internet connection.');
    }
    setLoadingRecap(false);
  };

  const saveApiKey = () => {
    if (apiKey.trim()) {
      localStorage.setItem('gemini_api_key', apiKey.trim());
      setShowApiKeyPrompt(false);
      
      const savedPosition = localStorage.getItem(`bookmark_${file.name}`);
      if (savedPosition && parseInt(savedPosition) > 500) {
        setShowRecap(true);
        generateRecap(savedPosition, apiKey.trim());
      } else if (savedPosition) {
        setTimeout(() => {
          contentRef.current.scrollTop = parseInt(savedPosition);
        }, 100);
      }
    }
  };

  const skipRecap = () => {
    setShowApiKeyPrompt(false);
    const savedPosition = localStorage.getItem(`bookmark_${file.name}`);
    if (savedPosition && contentRef.current) {
      setTimeout(() => {
        contentRef.current.scrollTop = parseInt(savedPosition);
      }, 100);
    }
  };

  const continueReading = () => {
    setShowRecap(false);
    const savedPosition = localStorage.getItem(`bookmark_${file.name}`);
    if (savedPosition && contentRef.current) {
      setTimeout(() => {
        contentRef.current.scrollTop = parseInt(savedPosition);
      }, 100);
    }
  };

  const handleFileUpload = async (e) => {
    const uploadedFile = e.target.files[0];
    if (!uploadedFile) return;

    setLoading(true);
    setFile(uploadedFile);
    setError('');
    setContent('');
    setShowUpload(false);
    setShowStartScreen(false);
    
    // Save to history
    saveToHistory(uploadedFile.name);
    
    const fileName = uploadedFile.name.toLowerCase();
    const type = uploadedFile.type;
    setFileType(type);

    try {
      if (fileName.endsWith('.pdf') || type === 'application/pdf') {
        await handlePDF(uploadedFile);
      } else if (fileName.endsWith('.epub') || type === 'application/epub+zip') {
        await handleEPUB(uploadedFile);
      } else {
        throw new Error('Unsupported file type. Please upload a PDF or EPUB file.');
      }
    } catch (error) {
      console.error('Error loading file:', error);
      setError(`Error: ${error.message || 'Could not load file. Please try a different file.'}`);
      setContent('');
    }
    
    setLoading(false);
  };

  const handlePDF = async (file) => {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const uint8Array = new Uint8Array(arrayBuffer);
      
      let binary = '';
      const chunkSize = 8192;
      for (let i = 0; i < uint8Array.length; i += chunkSize) {
        const chunk = uint8Array.subarray(i, Math.min(i + chunkSize, uint8Array.length));
        binary += String.fromCharCode.apply(null, chunk);
      }
      const base64 = btoa(binary);
      
      setContent(`
        <div style="width: 100%; height: 100%; display: flex; justify-content: center;">
          <embed 
            src="data:application/pdf;base64,${base64}" 
            type="application/pdf" 
            width="100%" 
            height="700px"
            style="border: none;"
          />
        </div>
      `);
    } catch (err) {
      throw new Error('Failed to load PDF file. The file may be corrupted or too large.');
    }
  };

  const handleEPUB = async (file) => {
    try {
      const JSZip = await loadJSZip();
      
      const arrayBuffer = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(arrayBuffer);
      
      let htmlContent = '';
      
      const possiblePaths = [
        'OEBPS/content.opf',
        'OPS/content.opf', 
        'EPUB/content.opf',
        'content.opf'
      ];
      
      let contentOpf = null;
      for (const path of possiblePaths) {
        try {
          contentOpf = await zip.file(path)?.async('string');
          if (contentOpf) break;
        } catch (e) {
          continue;
        }
      }
      
      if (contentOpf) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(contentOpf, 'text/xml');
        const manifest = doc.querySelectorAll('manifest item[media-type*="html"]');
        
        for (let item of manifest) {
          const href = item.getAttribute('href');
          if (!href) continue;
          
          const basePaths = ['OEBPS/', 'OPS/', 'EPUB/', ''];
          let fileContent = null;
          
          for (const basePath of basePaths) {
            try {
              fileContent = await zip.file(basePath + href)?.async('string');
              if (fileContent) break;
            } catch (e) {
              continue;
            }
          }
          
          if (fileContent) {
            const contentDoc = parser.parseFromString(fileContent, 'text/html');
            const body = contentDoc.querySelector('body');
            if (body) {
              htmlContent += body.innerHTML + '<div style="height: 40px;"></div>';
            }
          }
        }
      }
      
      if (!htmlContent) {
        const allFiles = Object.keys(zip.files);
        const htmlFiles = allFiles.filter(f => 
          (f.endsWith('.html') || f.endsWith('.xhtml')) && 
          !f.includes('nav.') && 
          !f.includes('toc.')
        );
        
        for (let filePath of htmlFiles) {
          try {
            const fileContent = await zip.file(filePath)?.async('string');
            if (fileContent) {
              const parser = new DOMParser();
              const doc = parser.parseFromString(fileContent, 'text/html');
              const body = doc.querySelector('body');
              if (body) {
                htmlContent += body.innerHTML + '<div style="height: 40px;"></div>';
              }
            }
          } catch (e) {
            console.error('Error reading file:', filePath, e);
          }
        }
      }
      
      if (!htmlContent || htmlContent.trim().length < 50) {
        throw new Error('No readable content found in EPUB file. The file may be encrypted or corrupted.');
      }
      
      setContent(htmlContent);
    } catch (err) {
      throw new Error(`Failed to load EPUB: ${err.message}`);
    }
  };

  return (
    <div style={{ 
      minHeight: '100vh', 
      background: '#ffffff',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      display: 'flex',
      flexDirection: 'column'
    }}>
      {/* Menu Bar */}
      <div style={{
        background: '#f8f8f8',
        borderBottom: '1px solid #e0e0e0',
        padding: '8px 16px',
        display: 'flex',
        alignItems: 'center',
        gap: '20px',
        fontSize: '14px'
      }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
          <span style={{ fontWeight: '500', cursor: 'pointer' }}>File</span>
          <span style={{ cursor: 'pointer', color: '#666' }}>Edit</span>
          <span style={{ cursor: 'pointer', color: '#666' }}>View</span>
          <span style={{ cursor: 'pointer', color: '#666' }}>Insert</span>
          <span style={{ cursor: 'pointer', color: '#666' }}>Format</span>
          <span style={{ cursor: 'pointer', color: '#666' }}>Tools</span>
          <span 
            onClick={() => setShowTutorial(true)}
            style={{ cursor: 'pointer', color: '#4a90e2', fontWeight: '500' }}
          >
            ðŸ“š Setup AI Recap
          </span>
          <span style={{ cursor: 'pointer', color: '#666' }}>Help</span>
        </div>
      </div>

      {/* Toolbar */}
      <div style={{
        background: '#fafafa',
        borderBottom: '1px solid #e0e0e0',
        padding: '8px 16px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        gap: '12px'
      }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <button
            onClick={() => setShowUpload(true)}
            style={{
              padding: '6px 12px',
              background: 'white',
              border: '1px solid #d0d0d0',
              borderRadius: '3px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              fontSize: '13px',
              color: '#333'
            }}
          >
            <FolderOpen size={16} />
            <span>Open</span>
          </button>
          <button
            style={{
              padding: '6px 12px',
              background: 'white',
              border: '1px solid #d0d0d0',
              borderRadius: '3px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              fontSize: '13px',
              color: '#333'
            }}
          >
            <Save size={16} />
            <span>Save</span>
          </button>
          
          <div style={{ width: '1px', height: '24px', background: '#d0d0d0', margin: '0 4px' }}></div>
          
          <button
            style={{
              padding: '6px 12px',
              background: 'white',
              border: '1px solid #d0d0d0',
              borderRadius: '3px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              fontSize: '13px',
              color: '#333'
            }}
          >
            <Copy size={16} />
          </button>
          <button
            style={{
              padding: '6px 12px',
              background: 'white',
              border: '1px solid #d0d0d0',
              borderRadius: '3px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              fontSize: '13px',
              color: '#333'
            }}
          >
            <Printer size={16} />
          </button>
        </div>

        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          {content && fileType !== 'application/pdf' && !file?.name.toLowerCase().endsWith('.pdf') && (
            <>
              <button
                onClick={() => setZoom(Math.max(50, zoom - 10))}
                style={{
                  padding: '6px 10px',
                  background: 'white',
                  border: '1px solid #d0d0d0',
                  borderRadius: '3px',
                  cursor: 'pointer',
                  fontSize: '13px',
                  color: '#333'
                }}
              >
                <ZoomOut size={16} />
              </button>
              <span style={{ fontSize: '13px', color: '#666', minWidth: '50px', textAlign: 'center' }}>{zoom}%</span>
              <button
                onClick={() => setZoom(Math.min(200, zoom + 10))}
                style={{
                  padding: '6px 10px',
                  background: 'white',
                  border: '1px solid #d0d0d0',
                  borderRadius: '3px',
                  cursor: 'pointer',
                  fontSize: '13px',
                  color: '#333'
                }}
              >
                <ZoomIn size={16} />
              </button>
            </>
          )}
        </div>
      </div>

      {/* Status Bar with filename */}
      {file && (
        <div style={{
          background: '#f0f0f0',
          borderBottom: '1px solid #e0e0e0',
          padding: '6px 16px',
          fontSize: '12px',
          color: '#666',
          display: 'flex',
          alignItems: 'center',
          gap: '8px'
        }}>
          <FileText size={14} />
          <span>{file.name}</span>
          <span style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: '15px' }}>
            <span>ðŸ“– Reading Progress: {readingProgress}%</span>
            <span>Read-only</span>
          </span>
        </div>
      )}

      {/* Main Editor Area */}
      <div style={{
        flex: 1,
        background: '#e8e8e8',
        overflow: 'auto',
        padding: '40px 20px'
      }}>
        {error && (
          <div style={{
            maxWidth: '800px',
            margin: '0 auto 20px',
            padding: '12px 16px',
            background: '#fff3cd',
            border: '1px solid #ffc107',
            borderRadius: '4px',
            display: 'flex',
            alignItems: 'start',
            gap: '10px'
          }}>
            <AlertCircle size={18} style={{ color: '#856404', flexShrink: 0 }} />
            <div style={{ fontSize: '13px', color: '#856404' }}>{error}</div>
          </div>
        )}

        {loading && (
          <div style={{ 
            maxWidth: '800px',
            margin: '0 auto',
            background: 'white',
            borderRadius: '2px',
            padding: '60px',
            textAlign: 'center',
            boxShadow: '0 1px 3px rgba(0,0,0,0.12)'
          }}>
            <div style={{
              display: 'inline-block',
              width: '40px',
              height: '40px',
              border: '4px solid #f3f3f3',
              borderTop: '4px solid #666',
              borderRadius: '50%',
              animation: 'spin 1s linear infinite'
            }} />
            <p style={{ marginTop: '20px', color: '#666', fontSize: '14px' }}>Loading document...</p>
            <style>{`
              @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
              }
            `}</style>
          </div>
        )}

                    {!content && !loading && !showUpload && !showStartScreen && (
          <div style={{
            maxWidth: '800px',
            margin: '0 auto',
            background: 'white',
            borderRadius: '2px',
            padding: '80px 40px',
            textAlign: 'center',
            boxShadow: '0 1px 3px rgba(0,0,0,0.12)'
          }}>
            <FileText size={64} style={{ color: '#ccc', marginBottom: '20px' }} />
            <h2 style={{ margin: '0 0 10px 0', fontSize: '18px', color: '#333', fontWeight: '400' }}>
              No document open
            </h2>
            <p style={{ margin: '0 0 25px 0', color: '#999', fontSize: '14px' }}>
              Start by opening a document
            </p>
            <button
              onClick={() => setShowUpload(true)}
              style={{
                padding: '10px 24px',
                background: '#4a90e2',
                color: 'white',
                border: 'none',
                borderRadius: '3px',
                cursor: 'pointer',
                fontSize: '14px'
              }}
            >
              Open Document
            </button>
          </div>
        )}

                    {showUpload && !content && !showStartScreen && (
          <div style={{
            maxWidth: '800px',
            margin: '0 auto',
            background: 'white',
            borderRadius: '2px',
            padding: '40px',
            boxShadow: '0 1px 3px rgba(0,0,0,0.12)'
          }}>
            <h3 style={{ margin: '0 0 20px 0', fontSize: '16px', color: '#333', fontWeight: '500' }}>
              Open Document
            </h3>
            <label style={{
              display: 'block',
              border: '2px dashed #ccc',
              borderRadius: '4px',
              padding: '40px 30px',
              textAlign: 'center',
              cursor: 'pointer',
              transition: 'all 0.2s ease',
              background: '#fafafa'
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.borderColor = '#4a90e2';
              e.currentTarget.style.background = '#f5f9fc';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.borderColor = '#ccc';
              e.currentTarget.style.background = '#fafafa';
            }}>
              <Upload size={40} style={{ color: '#999', marginBottom: '15px' }} />
              <div style={{ fontSize: '14px', fontWeight: '500', marginBottom: '8px', color: '#333' }}>
                Choose a file to open
              </div>
              <div style={{ color: '#999', fontSize: '13px' }}>
                Supported: PDF, EPUB
              </div>
              <input
                type="file"
                accept=".epub,.pdf,application/epub+zip,application/pdf"
                onChange={handleFileUpload}
                style={{ display: 'none' }}
              />
            </label>
            <div style={{ marginTop: '20px', textAlign: 'center' }}>
              <button
                onClick={() => setShowUpload(false)}
                style={{
                  padding: '8px 20px',
                  background: 'white',
                  color: '#666',
                  border: '1px solid #ccc',
                  borderRadius: '3px',
                  cursor: 'pointer',
                  fontSize: '13px'
                }}
              >
                Cancel
              </button>
            </div>
          </div>
        )}

        {content && !loading && (
          <div style={{
            maxWidth: '800px',
            margin: '0 auto',
            background: 'white',
            borderRadius: '2px',
            padding: '60px 80px',
            boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
            minHeight: '800px'
          }}>
            <div
              style={{
                fontSize: `${zoom}%`,
                lineHeight: '1.8',
                fontFamily: 'Georgia, "Times New Roman", serif',
                color: '#333'
              }}
              dangerouslySetInnerHTML={{ __html: content }}
            />
          </div>
        )}
      </div>

      {/* Bottom Status Bar */}
      <div style={{
        background: '#f0f0f0',
        borderTop: '1px solid #d0d0d0',
        padding: '4px 16px',
        fontSize: '12px',
        color: '#666',
        display: 'flex',
        justifyContent: 'space-between'
      }}>
        <span>Ready</span>
        <span>UTF-8</span>
      </div>
    </div>
  );
};

export default BookViewer;
